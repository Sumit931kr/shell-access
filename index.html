<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    * {
        margin: 0;
        padding: 0;
    }

    .main_container {
        background-color: rgb(213, 89, 89);
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;

    }

    .input_div {
        width: 80%;
        min-height: 300px;
        max-height: 80%;
        overflow-y: auto;
        font-size: 30px;
        background-color: antiquewhite;
        padding: 15px;
        border-radius: 10px;
        font-weight: lighter;
        scroll-behavior: smooth;
        padding: 10px 10px 50px 10px;
        /* margin-bottom: 20px; */
        font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
    }

    .dir {
        font-weight: bold !important;
    }
</style>

<body>
    <div class="main_container">
        <div class="input_div" contenteditable="true" id="editableDiv">


        </div>
    </div>
</body>

<script src="/socket.io/socket.io.js"></script>
<!-- <script src="/socket.io/other/socket.io.js"></script> -->
<script>

    // 
    let previousCommandsArray = [];
    let commandCounter = previousCommandsArray.length;

    const editableDiv = document.getElementById('editableDiv');


    editableDiv.addEventListener('keydown', function (event) {

        if (event.key === 'Enter') {
            event.preventDefault();

            currentLine = editableDiv.innerHTML
            currentLine = currentLine.trim()
            // console.log("currentLineArr ")

            // cutting some lines
            currentLineArr = currentLine.split("</span>");
            // console.log(currentLineArr)
            currentLine = currentLineArr[currentLineArr.length - 1]

            // console.log(currentLine)
            if (currentLine[currentLine.length - 1] == '>') {
                currentLine = "";
            }
            sendCommandHandler(currentLine)
            handleMoveCursorToEnd();
        }

        if (event.key == 'ArrowUp') {
            console.log("arraow up");
            if (commandCounter > 0) {
                commandCounter--;
            }

            if (previousCommandsArray[commandCounter]) {
                let allCommandArr = editableDiv.innerHTML.split('</span>');

                allCommandArr.pop();

                let allCommandStr = allCommandArr.join('</span>') + "</span>";

                let allCommand = `${allCommandStr}${previousCommandsArray[commandCounter]}`;

                editableDiv.innerHTML = allCommand;

            }
            handleMoveCursorToEnd();
        }
        if (event.key == 'ArrowDown') {
            console.log("arrow down");
            if (commandCounter <= previousCommandsArray.length - 1) {
                commandCounter++;
            }
            // console.log("Command counter "+ commandCounter)      
            // console.log(previousCommandsArray[commandCounter])
            // console.log(previousCommandsArray[commandCounter])
            if (previousCommandsArray[commandCounter]) {
                let allCommandArr = editableDiv.innerHTML.split('</span>');

                allCommandArr.pop();

                let allCommandStr = allCommandArr.join('</span>') + "</span>";

                let allCommand = `${allCommandStr}${previousCommandsArray[commandCounter]}`;

                editableDiv.innerHTML = allCommand;
            }
            else {
                let allCommandArr = editableDiv.innerHTML.split('</span>');

                allCommandArr.pop();

                let allCommandStr = allCommandArr.join('</span>') + "</span>";
                editableDiv.innerHTML = allCommandStr
            }
            handleMoveCursorToEnd();
        }


       setTimeout(() => {
           editableDiv.scrollTop = editableDiv.scrollHeight 
       }, 100);
    });

    const socket = io('/', {
        path: '/shell-access/socket.io/other'
        // path: '/socket.io/other'
    });


    socket.on('connect', () => {
        socket.emit('shell-connection', "ha");
    });


    socket.on("start", (dir) => {
        dir += " >"
        editableDiv.innerHTML = `<span class="dir" contenteditable="false">${dir}</span> `
        moveCursorToEnd(editableDiv)
    })
    socket.on("result", (res) => {
        // console.log(res)           
        editableDiv.innerHTML += `<pre>${res}</pre>`

    })

    socket.on("givedir", (dir) => {

        dir += " >"
        editableDiv.innerHTML += '<br/>' + `<span class="dir" contenteditable="false">${dir}</span> `

        editableDiv.scrollTop = editableDiv.scrollHeight
        moveCursorToEnd(editableDiv)
        // setCursorPosition(editableDiv, 135);
    })

    // send command handler
    const sendCommandHandler = (command) => {
        if (!command) return
        console.log(command)

        command = command.replaceAll('&nbsp;', ' ');

        command = command.trim()
        let sendAbleCommand = validateSentence(command);
        console.log("Send command " + sendAbleCommand);

        previousCommandsArray.push(sendAbleCommand)
        if (sendAbleCommand == 'clear') { window.location.reload(); return; }



        socket.emit('sendcommand', sendAbleCommand);
        commandCounter = previousCommandsArray.length;



    }


    // move the cursor to the end
    function moveCursorToEnd(element) {
        // Make sure the element is contentEditable
        element.contentEditable = true;

        // Create a new range
        let range = document.createRange();

        // Select the element
        range.selectNodeContents(element);

        // Collapse the range to the end
        range.collapse(false);

        // Get the selection object
        let selection = window.getSelection();

        // Remove any existing selections
        selection.removeAllRanges();

        // Add the new range
        selection.addRange(range);

        // Focus on the element
        element.focus();
    }

    const handleMoveCursorToEnd = () => {
        setTimeout(() => { moveCursorToEnd(editableDiv) }, 300)

    }


    // get previous commands



    // validate Sentence 

    const validateSentence = (sentence) => {
        if (!sentence) return "";

        return sentence.split(' ').map((el) => el.trim()).filter((el) => el !== "").join(' ')

    }

</script>

</html>